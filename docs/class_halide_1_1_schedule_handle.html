<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: Halide::ScheduleHandle Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_halide_1_1_schedule_handle.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Halide::ScheduleHandle Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Halide::ScheduleHandle" -->
<p>A wrapper around a schedule used for common schedule manipulations.  
 <a href="class_halide_1_1_schedule_handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>

<p><a href="class_halide_1_1_schedule_handle-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a5ad2d8b9dd4f722890654fa6c911e1aa">ScheduleHandle</a> (<a class="el" href="struct_halide_1_1_internal_1_1_schedule.html">Internal::Schedule</a> &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a82dcba5e287a284bfdb2eba997659daa">split</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> old, <a class="el" href="class_halide_1_1_var.html">Var</a> outer, <a class="el" href="class_halide_1_1_var.html">Var</a> inner, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1.  <a href="#a82dcba5e287a284bfdb2eba997659daa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a07b98d9cec11b5e3a17930b0b20d01be">fuse</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> inner, <a class="el" href="class_halide_1_1_var.html">Var</a> outer, <a class="el" href="class_halide_1_1_var.html">Var</a> fused)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a341ae03504ed0261b1ffba9935844c2d">parallel</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be traversed in parallel.  <a href="#a341ae03504ed0261b1ffba9935844c2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a965ef3a905df60c3f59ca3743cbf668d">vectorize</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be computed all-at-once as a single vector.  <a href="#a965ef3a905df60c3f59ca3743cbf668d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a0cf1e85d5dcb74d761d15546b5c6de90">unroll</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be completely unrolled.  <a href="#a0cf1e85d5dcb74d761d15546b5c6de90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a30332ea58e8ff19e426565ddb8814ae2">vectorize</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, int factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then vectorize the inner dimension.  <a href="#a30332ea58e8ff19e426565ddb8814ae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aab78461c04452c17b3b1534dcdd84505">unroll</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, int factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then unroll the inner dimension.  <a href="#aab78461c04452c17b3b1534dcdd84505"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a4cde6c7be1ecf477045302fc3f0d897e">bound</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">min</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically declare that the range over which a function should be evaluated is given by the second and third arguments.  <a href="#a4cde6c7be1ecf477045302fc3f0d897e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a5034fe9fbd89a2e6262bbdf3ac02a9fd">tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> xo, <a class="el" href="class_halide_1_1_var.html">Var</a> yo, <a class="el" href="class_halide_1_1_var.html">Var</a> xi, <a class="el" href="class_halide_1_1_var.html">Var</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards.  <a href="#a5034fe9fbd89a2e6262bbdf3ac02a9fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a8ac11ba997fa44891f995d9affb9591e">tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> xi, <a class="el" href="class_halide_1_1_var.html">Var</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A shorter form of tile, which reuses the old variable names as the new outer dimensions.  <a href="#a8ac11ba997fa44891f995d9affb9591e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">reorder</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder variables to have the given nesting order, from innermost out.  <a href="#a8ec6f1759c101513d56df7b1eaff0234"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a83f456d05588b88f1ea6707875bf68a8">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder two dimensions so that x is traversed inside y.  <a href="#a83f456d05588b88f1ea6707875bf68a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a33060b1c2876ccb6fe025d4a401b95a7">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder three dimensions to have the given nesting order, from innermost out.  <a href="#a33060b1c2876ccb6fe025d4a401b95a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a24779097a7a7988bc37625c49d0ebeb5">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder four dimensions to have the given nesting order, from innermost out.  <a href="#a24779097a7a7988bc37625c49d0ebeb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a4e0e628eaa175301bc30125b4670d79c">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder five dimensions to have the given nesting order, from innermost out.  <a href="#a4e0e628eaa175301bc30125b4670d79c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#ad3b0ad85a44d553d1f06f652097e1d5a">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t1, <a class="el" href="class_halide_1_1_var.html">Var</a> t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder six dimensions to have the given nesting order, from innermost out.  <a href="#ad3b0ad85a44d553d1f06f652097e1d5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a28547227c2cf6f3108d1e74426cc639d">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t1, <a class="el" href="class_halide_1_1_var.html">Var</a> t2, <a class="el" href="class_halide_1_1_var.html">Var</a> t3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder seven dimensions to have the given nesting order, from innermost out.  <a href="#a28547227c2cf6f3108d1e74426cc639d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#ae5efac430b2a489f92c96d58282dfe9b">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t1, <a class="el" href="class_halide_1_1_var.html">Var</a> t2, <a class="el" href="class_halide_1_1_var.html">Var</a> t3, <a class="el" href="class_halide_1_1_var.html">Var</a> t4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder eight dimensions to have the given nesting order, from innermost out.  <a href="#ae5efac430b2a489f92c96d58282dfe9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#ae519bf833a76570670e5b1572a3721c8">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t1, <a class="el" href="class_halide_1_1_var.html">Var</a> t2, <a class="el" href="class_halide_1_1_var.html">Var</a> t3, <a class="el" href="class_halide_1_1_var.html">Var</a> t4, <a class="el" href="class_halide_1_1_var.html">Var</a> t5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder nine dimensions to have the given nesting order, from innermost out.  <a href="#ae519bf833a76570670e5b1572a3721c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a3b4840b15f6f80eaaa45bbe3551fdb2b">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t1, <a class="el" href="class_halide_1_1_var.html">Var</a> t2, <a class="el" href="class_halide_1_1_var.html">Var</a> t3, <a class="el" href="class_halide_1_1_var.html">Var</a> t4, <a class="el" href="class_halide_1_1_var.html">Var</a> t5, <a class="el" href="class_halide_1_1_var.html">Var</a> t6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder ten dimensions to have the given nesting order, from innermost out.  <a href="#a3b4840b15f6f80eaaa45bbe3551fdb2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#ae3cc45869ffbe51fa95f3fe7bc0f8463">rename</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> old_name, <a class="el" href="class_halide_1_1_var.html">Var</a> new_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a dimension.  <a href="#ae3cc45869ffbe51fa95f3fe7bc0f8463"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aac3fd49ab9a92485f2a24ed997b2c46e">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices.  <a href="#aac3fd49ab9a92485f2a24ed997b2c46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aa964092fe660a59129d3ac20feb1867b">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices.  <a href="#aa964092fe660a59129d3ac20feb1867b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a43f6c5ca23e42a04a654a0e6daaf81f7">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices.  <a href="#a43f6c5ca23e42a04a654a0e6daaf81f7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a138e0ce958cda731f080088fb7f89a3b">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices.  <a href="#a138e0ce958cda731f080088fb7f89a3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a2c1a089eab2c71f57e6e1f2f225b683f">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices.  <a href="#a2c1a089eab2c71f57e6e1f2f225b683f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#abc11aebb55ad93ae7a2d9e80ebf260f4">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> block_z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices.  <a href="#abc11aebb55ad93ae7a2d9e80ebf260f4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices.  <a href="#acf7d873d44842d0f3116e6fbebd86507"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a6bf73d51bde948e08ac781639b4008d2">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices.  <a href="#a6bf73d51bde948e08ac781639b4008d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a033f1275529d5387491db06718fe434c">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> block_z, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices.  <a href="#a033f1275529d5387491db06718fe434c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, int x_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices.  <a href="#aca3bf0f68bb50a1e2a7920cffc024737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a16ed2ef297d71d526311638e3c59ff8a">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, int x_size, int y_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices.  <a href="#a16ed2ef297d71d526311638e3c59ff8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#ab9893c5369e40d5df86673e34894bf68">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, int x_size, int y_size, int z_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices.  <a href="#ab9893c5369e40d5df86673e34894bf68"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A wrapper around a schedule used for common schedule manipulations. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00172">172</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5ad2d8b9dd4f722890654fa6c911e1aa"></a><!-- doxytag: member="Halide::ScheduleHandle::ScheduleHandle" ref="a5ad2d8b9dd4f722890654fa6c911e1aa" args="(Internal::Schedule &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_schedule_handle.html#a5ad2d8b9dd4f722890654fa6c911e1aa">Halide::ScheduleHandle::ScheduleHandle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_schedule.html">Internal::Schedule</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l00177">177</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a82dcba5e287a284bfdb2eba997659daa"></a><!-- doxytag: member="Halide::ScheduleHandle::split" ref="a82dcba5e287a284bfdb2eba997659daa" args="(Var old, Var outer, Var inner, Expr factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a82dcba5e287a284bfdb2eba997659daa">Halide::ScheduleHandle::split</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1. </p>
<p>The inner and outer subdimensions can then be dealt with using the other scheduling calls. It's ok to reuse the old variable name as either the inner or outer variable. </p>

</div>
</div>
<a class="anchor" id="a07b98d9cec11b5e3a17930b0b20d01be"></a><!-- doxytag: member="Halide::ScheduleHandle::fuse" ref="a07b98d9cec11b5e3a17930b0b20d01be" args="(Var inner, Var outer, Var fused)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a07b98d9cec11b5e3a17930b0b20d01be">Halide::ScheduleHandle::fuse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>fused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a341ae03504ed0261b1ffba9935844c2d"></a><!-- doxytag: member="Halide::ScheduleHandle::parallel" ref="a341ae03504ed0261b1ffba9935844c2d" args="(Var var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a341ae03504ed0261b1ffba9935844c2d">Halide::ScheduleHandle::parallel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark a dimension to be traversed in parallel. </p>

</div>
</div>
<a class="anchor" id="a965ef3a905df60c3f59ca3743cbf668d"></a><!-- doxytag: member="Halide::ScheduleHandle::vectorize" ref="a965ef3a905df60c3f59ca3743cbf668d" args="(Var var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a965ef3a905df60c3f59ca3743cbf668d">Halide::ScheduleHandle::vectorize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark a dimension to be computed all-at-once as a single vector. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of vectorize you want the two argument form. The variable to be vectorized should be the innermost one. </p>

</div>
</div>
<a class="anchor" id="a0cf1e85d5dcb74d761d15546b5c6de90"></a><!-- doxytag: member="Halide::ScheduleHandle::unroll" ref="a0cf1e85d5dcb74d761d15546b5c6de90" args="(Var var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a0cf1e85d5dcb74d761d15546b5c6de90">Halide::ScheduleHandle::unroll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark a dimension to be completely unrolled. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of unroll you want the two-argument form. </p>

</div>
</div>
<a class="anchor" id="a30332ea58e8ff19e426565ddb8814ae2"></a><!-- doxytag: member="Halide::ScheduleHandle::vectorize" ref="a30332ea58e8ff19e426565ddb8814ae2" args="(Var var, int factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a965ef3a905df60c3f59ca3743cbf668d">Halide::ScheduleHandle::vectorize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a dimension by the given factor, then vectorize the inner dimension. </p>
<p>This is how you vectorize a loop of unknown size. The variable to be vectorized should be the innermost one. After this call, var refers to the outer dimension of the split. </p>

</div>
</div>
<a class="anchor" id="aab78461c04452c17b3b1534dcdd84505"></a><!-- doxytag: member="Halide::ScheduleHandle::unroll" ref="aab78461c04452c17b3b1534dcdd84505" args="(Var var, int factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a0cf1e85d5dcb74d761d15546b5c6de90">Halide::ScheduleHandle::unroll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a dimension by the given factor, then unroll the inner dimension. </p>
<p>This is how you unroll a loop of unknown size by some constant factor. After this call, var refers to the outer dimension of the split. </p>

</div>
</div>
<a class="anchor" id="a4cde6c7be1ecf477045302fc3f0d897e"></a><!-- doxytag: member="Halide::ScheduleHandle::bound" ref="a4cde6c7be1ecf477045302fc3f0d897e" args="(Var var, Expr min, Expr extent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a4cde6c7be1ecf477045302fc3f0d897e">Halide::ScheduleHandle::bound</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically declare that the range over which a function should be evaluated is given by the second and third arguments. </p>
<p>This can let <a class="el" href="namespace_halide.html">Halide</a> perform some optimizations. E.g. if you know there are going to be 4 color channels, you can completely vectorize the color channel dimension without the overhead of splitting it up. If bounds inference decides that it requires more of this function than the bounds you have stated, a runtime error will occur when you try to run your pipeline. </p>

</div>
</div>
<a class="anchor" id="a5034fe9fbd89a2e6262bbdf3ac02a9fd"></a><!-- doxytag: member="Halide::ScheduleHandle::tile" ref="a5034fe9fbd89a2e6262bbdf3ac02a9fd" args="(Var x, Var y, Var xo, Var yo, Var xi, Var yi, Expr xfactor, Expr yfactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a5034fe9fbd89a2e6262bbdf3ac02a9fd">Halide::ScheduleHandle::tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards. </p>
<p>This gives a tiled traversal. </p>

</div>
</div>
<a class="anchor" id="a8ac11ba997fa44891f995d9affb9591e"></a><!-- doxytag: member="Halide::ScheduleHandle::tile" ref="a8ac11ba997fa44891f995d9affb9591e" args="(Var x, Var y, Var xi, Var yi, Expr xfactor, Expr yfactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a5034fe9fbd89a2e6262bbdf3ac02a9fd">Halide::ScheduleHandle::tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A shorter form of tile, which reuses the old variable names as the new outer dimensions. </p>

</div>
</div>
<a class="anchor" id="a8ec6f1759c101513d56df7b1eaff0234"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="a8ec6f1759c101513d56df7b1eaff0234" args="(const std::vector&lt; Var &gt; &amp;vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder variables to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a83f456d05588b88f1ea6707875bf68a8"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="a83f456d05588b88f1ea6707875bf68a8" args="(Var x, Var y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder two dimensions so that x is traversed inside y. </p>
<p>Does not affect the nesting order of other dimensions. E.g, if you say foo(x, y, z, w) = bar; foo.reorder(w, x); then foo will be traversed in the order (w, y, z, x), from innermost outwards. </p>

</div>
</div>
<a class="anchor" id="a33060b1c2876ccb6fe025d4a401b95a7"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="a33060b1c2876ccb6fe025d4a401b95a7" args="(Var x, Var y, Var z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder three dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a24779097a7a7988bc37625c49d0ebeb5"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="a24779097a7a7988bc37625c49d0ebeb5" args="(Var x, Var y, Var z, Var w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder four dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a4e0e628eaa175301bc30125b4670d79c"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="a4e0e628eaa175301bc30125b4670d79c" args="(Var x, Var y, Var z, Var w, Var t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder five dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="ad3b0ad85a44d553d1f06f652097e1d5a"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="ad3b0ad85a44d553d1f06f652097e1d5a" args="(Var x, Var y, Var z, Var w, Var t1, Var t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder six dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a28547227c2cf6f3108d1e74426cc639d"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="a28547227c2cf6f3108d1e74426cc639d" args="(Var x, Var y, Var z, Var w, Var t1, Var t2, Var t3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder seven dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="ae5efac430b2a489f92c96d58282dfe9b"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="ae5efac430b2a489f92c96d58282dfe9b" args="(Var x, Var y, Var z, Var w, Var t1, Var t2, Var t3, Var t4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder eight dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="ae519bf833a76570670e5b1572a3721c8"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="ae519bf833a76570670e5b1572a3721c8" args="(Var x, Var y, Var z, Var w, Var t1, Var t2, Var t3, Var t4, Var t5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder nine dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a3b4840b15f6f80eaaa45bbe3551fdb2b"></a><!-- doxytag: member="Halide::ScheduleHandle::reorder" ref="a3b4840b15f6f80eaaa45bbe3551fdb2b" args="(Var x, Var y, Var z, Var w, Var t1, Var t2, Var t3, Var t4, Var t5, Var t6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a8ec6f1759c101513d56df7b1eaff0234">Halide::ScheduleHandle::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder ten dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="ae3cc45869ffbe51fa95f3fe7bc0f8463"></a><!-- doxytag: member="Halide::ScheduleHandle::rename" ref="ae3cc45869ffbe51fa95f3fe7bc0f8463" args="(Var old_name, Var new_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#ae3cc45869ffbe51fa95f3fe7bc0f8463">Halide::ScheduleHandle::rename</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename a dimension. </p>
<p>Equivalent to split with a inner size of one. </p>

</div>
</div>
<a class="anchor" id="aac3fd49ab9a92485f2a24ed997b2c46e"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_threads" ref="aac3fd49ab9a92485f2a24ed997b2c46e" args="(Var thread_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#aac3fd49ab9a92485f2a24ed997b2c46e">Halide::ScheduleHandle::cuda_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to cuda threads. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="aa964092fe660a59129d3ac20feb1867b"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_threads" ref="aa964092fe660a59129d3ac20feb1867b" args="(Var thread_x, Var thread_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#aac3fd49ab9a92485f2a24ed997b2c46e">Halide::ScheduleHandle::cuda_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to cuda threads. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a43f6c5ca23e42a04a654a0e6daaf81f7"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_threads" ref="a43f6c5ca23e42a04a654a0e6daaf81f7" args="(Var thread_x, Var thread_y, Var thread_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#aac3fd49ab9a92485f2a24ed997b2c46e">Halide::ScheduleHandle::cuda_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to cuda threads. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a138e0ce958cda731f080088fb7f89a3b"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_blocks" ref="a138e0ce958cda731f080088fb7f89a3b" args="(Var block_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a138e0ce958cda731f080088fb7f89a3b">Halide::ScheduleHandle::cuda_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices. </p>
<p>This is useful for scheduling stages that will run serially within each cuda block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a2c1a089eab2c71f57e6e1f2f225b683f"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_blocks" ref="a2c1a089eab2c71f57e6e1f2f225b683f" args="(Var block_x, Var block_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a138e0ce958cda731f080088fb7f89a3b">Halide::ScheduleHandle::cuda_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices. </p>
<p>This is useful for scheduling stages that will run serially within each cuda block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="abc11aebb55ad93ae7a2d9e80ebf260f4"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_blocks" ref="abc11aebb55ad93ae7a2d9e80ebf260f4" args="(Var block_x, Var block_y, Var block_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#a138e0ce958cda731f080088fb7f89a3b">Halide::ScheduleHandle::cuda_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices. </p>
<p>This is useful for scheduling stages that will run serially within each cuda block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="acf7d873d44842d0f3116e6fbebd86507"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda" ref="acf7d873d44842d0f3116e6fbebd86507" args="(Var block_x, Var thread_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">Halide::ScheduleHandle::cuda</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="a6bf73d51bde948e08ac781639b4008d2"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda" ref="a6bf73d51bde948e08ac781639b4008d2" args="(Var block_x, Var block_y, Var thread_x, Var thread_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">Halide::ScheduleHandle::cuda</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="a033f1275529d5387491db06718fe434c"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda" ref="a033f1275529d5387491db06718fe434c" args="(Var block_x, Var block_y, Var block_z, Var thread_x, Var thread_y, Var thread_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">Halide::ScheduleHandle::cuda</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="aca3bf0f68bb50a1e2a7920cffc024737"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_tile" ref="aca3bf0f68bb50a1e2a7920cffc024737" args="(Var x, int x_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">Halide::ScheduleHandle::cuda_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<a class="anchor" id="a16ed2ef297d71d526311638e3c59ff8a"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_tile" ref="a16ed2ef297d71d526311638e3c59ff8a" args="(Var x, Var y, int x_size, int y_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">Halide::ScheduleHandle::cuda_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<a class="anchor" id="ab9893c5369e40d5df86673e34894bf68"></a><!-- doxytag: member="Halide::ScheduleHandle::cuda_tile" ref="ab9893c5369e40d5df86673e34894bf68" args="(Var x, Var y, Var z, int x_size, int y_size, int z_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; <a class="el" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">Halide::ScheduleHandle::cuda_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a>      </li>
      <li class="navelem"><a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>      </li>

    <li class="footer">Generated on Mon Nov 4 2013 15:36:33 for Halide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
